***A Three-Dimensional Cartesian Mesh Generation Algorithm Based on the GPU Parallel Ray Casting Method***
**一种基于GPU并行射线投射法的三维笛卡尔网格生成算法**

#### *Abstract*

大规模场景下鲁棒高效的笛卡尔网格生成对于**流体动力学仿真**和**碰撞检测**具有重要意义。高质量大规模的网格生成任务在个人计算机上是很难实现的。本文提出了一种基于GPU的并行笛卡尔网格生成算法。该算法在计算机图形学中的传统射线投射方法的基础上进行了优化，对于大规模笛卡尔网格生成更高效、更稳定。在网格生成过程中，由三角形小面表示的几何体被转换为由正六面体组成的网格。提出了一种并行射线生成方法，以减少主机内存和设备内存之间的数据交换。采用基于栅格的并行基元搜索方法，搜索三角形小面，用于射线和三角形的交点计算。利用CUDA库实现了并行笛卡尔网格生成算法。与传统的串行算法相比，并行笛卡尔网格生成算法的性能有了很大提高，这在不同的数值实验中得到了证明。通过一些测试，分析了并行算法的性能，结果表明GPU的并行计算能力得到了充分利用。最后，给出了笛卡尔网格生成的例子。

#### *Keywords*

网格生成、GPU并行计算、计算几何、数值仿真。

#### *Introduction*

笛卡尔网格已被广泛用于计算流体动力学、计算爆炸力学和计算机图形学，如碰撞检测。笛卡尔网格通常用作三维几何体的近似离散化。如图1所示，这种数值网格由多个正六面体堆砌而成，属于不同物质的网格边界呈梯形。在图1中，二维计算域中有两种物质，分别用蓝色和白色表示，包含椭圆的计算域被网格化到笛卡尔网格中。在计算流体动力学应用中，几何边界条件离散到笛卡尔网格中，物理量分配到网格单元上。单元上的物理量的值将随着计算过程而更新，并将其视为连续物理空间中物理量的近似值。在计算机图形应用中，笛卡尔网格生成过程与体素化类似，体素化可用于三维游戏中的渲染场景。在计算机游戏领域，关于体素化的研究多种多样。本文提出的算法重点是在流体力学、爆炸力学和电磁数值模拟中的应用。在这些领域中，生成的网格单元数量远大于三维电脑游戏中的单元网格数量，通常可以达到10^10^个。虽然实时性不是必需的，但是网格的生成效率对数值模拟的效率有很大影响，因此高效的笛卡尔网格生成需要引起重视。

<div align=center><img width="400" src="/applsci-10-00058-g001.jpg"></div> 
<div align=center><font color=#FF0000 size=4 face="楷体"><b>图1 二维平面中的笛卡尔网格示例</b></font></div>

大规模笛卡尔网格生成有两种流行的算法。一种是射线投射算法，创建一系列射线，并计算射线和几何体的交点。该方法由于其流程清晰、简单，通常被应用于大规模网格生成中。然而，由于几何交点计算耗时巨大，此算法效率有待提高。另一种是切片算法，指的是快速原型加工的思想，使用一系列平行平面切割几何体，以获得每个平面中的轮廓。然后，三维空间中的笛卡尔网格生成任务就转换成了二维平面中的类似任务了。该方法可以在网格生成过程中获得更多的几何信息。然而，拓扑重建的过程必须添加到切片算法中，这会导致效率下降。此外，还必须添加一个预处理程序，这使算法过于繁琐以致于算法的鲁棒性和适应性都有待提高，并且网格生成过程不利于大规模并行。考虑到在大规模复杂场景下的三维笛卡尔网格生成中的大量网格单元，*MacGillivary*采用高精度射线-小面交点测试和基于传统射线投射算法的高效数据存储方法，实现了万亿笛卡尔网格单元的生成。但是这一成果在效率和适应性上仍有一些细节有待提高，他们的算法是一种串行算法。

对于大规模场景，时间消耗是笛卡尔网格生成的最大限制。GPU并行计算或许是突破性能瓶颈的最佳选择。*Park*和*Shin*提出了一种基于GPU的三维自适应笛卡尔网格生成方法。*Schwarz*和*Seidel*提出了一种基于GPU的快速并行表面和实体体素化，可以实时将几何体离散为二进制体素。他们的算法使用八叉树作为离散结果，可以有效地用于碰撞检测应用。然而，网格单元的数量太小，无法用于流体动力学的数值模拟。*Cohenor*和*Pantaleoni*实现了类似工作。在网格生成过程中，大部分的工作集中在射线和三角形小面间的交点计算上。因此，快速小面搜索方法是一个关键点。K维树和包围盒层次树通常用于搜索三维动态场景下的几何基元。*Shevtsov*等人提出了一种使用并行KD树渲染场景的并行射线跟踪算法。*Wehr*和*Radkowski*引入了一种GPU上三维点的并行KD树构造方法，该方法采用排序算法在构造过程中保持高并行度。*Lauterbach*和*Ganestam*实现了在GPU上并行构建BVH树用于场景渲染。在本文的笛卡尔网格生成算法中，在二维投影平面上进行基元搜索，基元在计算域中的位置不改变。因此，在笛卡尔网格生成中采用了栅格方法。

本文提出了一种基于GPU的并行笛卡尔网格生成算法。在2.2节中，提出了一种GPU上的并行射线生成方法，以减少主机内存和设备内存之间的数据交换。在2.3节中，采用基于栅格的基元搜索方法搜索三角形面用于射线和三角形小面的交点计算。笛卡尔网格生成的一些示例见3.1节。并行算法和传统算法的性能分析和比较见3.2节。

#### *Materials and Methods*

通常，射线投射算法是生成笛卡尔网格最流行和最准确的方法。经典的射线投射算法可以通过简单的过程生成大量的网格单元，其优点包括更高的稳定性和并行度。射线投射算法包含三个主要步骤：射线生成、交点计算和属性映射。在以下各节中，将分别介绍上述每个步骤的并行化方法。

##### *Baseline of Ray Casting Algorithm*
网格生成过程中所需的所有几何信息都可以从STL文件中提取，其中几何体被离散成三角形小面，并存储三角形小面的三维坐标和法向量。在一些网格生成的切片算法中，必须过滤STL文件中主要包含相同顶点坐标的冗余信息，重建几何拓扑信息。然而，为了避免这一缺点，本文的射线投射算法将STL文件中的所有三角形集T和法向量集N作为必要的输入信息。笛卡尔网格生成的目的是通过T和N获得三维数据字段F。F中每个元素的值是每个网格单元的属性标志。如图2a所示，立方体计算域包含四个几何体。蓝色平面（图2中的XY平面）是射线开始的投影平面。从投影平面上的点开始，以Z维方向发射一系列射线。通常，选择计算域三个维度中的最大维度作为射线方向。如图2b所示，射线穿过整个计算域并与几何体相交。通过交点，网格单元格被分类为不同的标志。标志F的集合是笛卡尔网格生成的结果。图2c展示了网格计算域中一个几何体的网格生成结果。

<div align=center><img width="400" src="/applsci-10-00058-g002.jpg"></div> 
<div align=center><font color=#FF0000 size=4 face="楷体"><b>图2 笛卡尔网格生成基础模型图</b></font></div>
<div align=center><font color=#FF0000 size=4 face="楷体"><b>(a)计算域 (b)一条射线通过计算域 (c)网格生成结果</b></font></div>

##### *Parallel Ray Generation*
射线的起点分布是根据计算任务生成的，计算任务由网格大小决定，直接影响网格生成的质量。由于射线数量巨大，直接在设备内存中生成起点比在主机内存生成起点再传输到设备内存更有效。在本小节中，通过优化算法确定网格大小，然后提出了一种在单个GPU线程中生成射线坐标的方法。
假设计算域是立方体区域，这个计算域可以由两点固定：p~1~(x~1~,y~1~,z~1~)和p~2~(x~2~,y~2~,z~2~)。域中有一些几何体，域中的所有几何体都将按顺序网格化。第一步是计算每个几何体的边界框。G~i~的边界框可以由最小点p~min~和最大点p~max~定义。均匀的笛卡尔网格的网格尺寸等于整个三维计算域中的常数值s~opt~。以X维为例，X维被几何体的边界框划分为几个区间，X~i~定义为区间边界，n~x~为区间的端点数。必须满足两个限制：(a)区间的端点必须是网格线的一部分；(b)每个几何体G~i~的单元尺寸不超过最大尺寸s~max~。根据几何体的特性和计算需求，可以人为选择s~max~。
首先，必须计算满足上述限制的最大网格单元尺寸s~opt~。为了获得优化的网格单元尺寸，X、Y和Z维的单元尺寸函数可以表示为公式(1)-(3)，优化后的单元尺寸分别可以通过最小化这三个函数计算得到。

$$f_x(s_{x,opt}) = \sum_{i=1}^{n_{x}-1}(\frac{\Delta{X_i}}{s_{x,opt}}) \tag{1} $$

$$f_y(s_{y,opt}) = \sum_{j=1}^{n_{y}-1}(\frac{\Delta{Y_j}}{s_{y,opt}}) \tag{2} $$

$$f_z(s_{z,opt}) = \sum_{k=1}^{n_{z}-1}(\frac{\Delta{Z_i}}{s_{z,opt}}) \tag{3} $$

$$\Delta{X_i} = X_{i+1} - X_i \quad i = 1,…,n_x-1 \tag{4}$$

$$\Delta{Y_i} = Y_{j+1} - X_j \quad j = 1,…,n_y-1 \tag{5}$$

$$\Delta{Z_i} = Z_{k+1} - X_k \quad k = 1,…,n_z-1 \tag{6}$$

然后，通过边界框的最小点和优化后的网格单元尺寸s~opt~，可以根据公式(7)-(9)计算网格线的坐标。获得网格线后，就可以计算射线的起点。射线和网格线的生成过程如图3所示。

$$x_i = x_{min} + i \times s_{x,opt} \quad i = 0,…,n_x-1 \tag{7}$$

$$y_j = y_{min} + j \times s_{y,opt} \quad j = 0,…,n_y-1 \tag{8}$$

$$z_k = z_{min} + k \times s_{z,opt} \quad k = 0,…,n_z-1 \tag{9}$$

<div align=center><img width="400" src="/applsci-10-00058-g003.jpg"></div> 
<div align=center><font color=#FF0000 size=4 face="楷体"><b>图3 笛卡尔网格线分布和基于射线投射法的射线生成示意图</b></font></div>

当并行程序在GPU上运行时，初始数据应从主机内存传输到设备内存。因此，程序中发生的数据传输越少，程序越高效。为了减少数据传输，射线生成、交点计算和属性映射都在GPU上执行。基本上，只需要两次数据传输，即从主机传输到设备的初始计算域的信息和从设备传输到主机的网格信息。初始计算域信息包括：表示边界框的两个点的坐标、三角形小面的坐标数组和法向量数组以及优化后的网格单元尺寸s~opt~。根据以上数据，每条射线的坐标都可以在单个GPU线程中使用公式(10)计算得到。

$$
\begin{cases}x_r = x_{min} + s_x/2 + \text{(Idx \% } n_x)\times s_x \\
y_r = y_{min} + s_y/2 + (Idx/n_x)\times s_y
\end{cases} \tag{10}
$$

其中Idx和n~x~可以分别通过公式(11)和(12)计算。

$$Idx = threadIdx + blockIdx\times blockDim \tag{11}$$

$$n_x = \frac{x_2 - x_1}{s_x} \tag{12}$$

其中threadIdx和blockIdx分别是当前线程和线程块的索引，blockDim是X维中的线程块数。线程块和线程都是GPU中的逻辑结构。

##### *Parallel Lattice Grid Method*
为了计算射线和面之间的交点，我们需要首先确定面是否可能与射线相交。为了实现这一目标，三角形小面被组织为栅格数据结构。如图4所示，投影平面被划分为一系列栅格。如果小面与网格重叠，小面将由特定的网格索引标记。因此，对于栅格中的射线，只需要检测由当前网格索引标记的三角形。未被当前网格标记的三角形不参与当前步骤，这大大减少了射线和三角形小面之间交点的计算时间。此外，索引标记的过程可以并行执行，这消除了栅格构建造成的额外时间消耗。边界函数用于检测投影平面中的重叠。如图5所示，假设小面的法向量为n，小面的边界为e~i~，v~0~、v~1~和v~2~是小面的顶点。根据方程(13)和(14)，计算得到n<sub>e<sub>i</sub></sub>和d<sub>e<sub>i</sub></sub>。然后，对于所有三条边，检测公式(15)是否为真。如果为真，那么小面与网格重叠。

$$
n_{e_i} = (-e_{i,y}, e_{i,x})^T \cdot\begin{cases}1,\quad n_z \ge 0 \\
-1,\quad n_z < 0
\end{cases} \tag{13}
$$

$$d_{e_i} = -\langle n_{e_i},v_i \rangle + max\{0,\Delta p_xn_{e_i, x}\} + max\{0,\Delta p_yn_{e_i, y}\} \tag{14}$$

$$\bigcap_{i=0}^2 (\langle n_{e_i}, p_{min} \rangle + d_{e_i} > 0) \tag{15}$$

其中，$\Delta p = p_{max} - p_{min}$，这里需要注意的一个重点是，p~min~和p~max~分别是当前栅格（子边界框）中起始和结束射线起点坐标。参与计算的点是网格单元中心点。

<div align=center><img width="400" src="/applsci-10-00058-g004.jpg"></div> 
<div align=center><font color=#FF0000 size=4 face="楷体"><b>图4 栅格法基元搜索示意图</b></font></div>

<div align=center><img width="400" src="/applsci-10-00058-g005.jpg"></div> 
<div align=center><font color=#FF0000 size=4 face="楷体"><b>图5 投影平面中三角形小面和网格的重叠检测示意图</b></font></div>
<div align=center><font color=#FF0000 size=4 face="楷体">Sx和Sy分别为单元X维和Y维的尺寸</font></div>

##### *Parallel Intersection Calculation*
在三维空间中，射线穿过整个计算域，并与几何体中的一些三角形小面相交。通过栅格法，排除了大多数不可能与特定射线相交的三角形。为了计算射线和小面的交点，我们只需要在候选三角形中找到三角形。采用了一种不进行除法计算的交点检测方法，这种方法可以减少机器误差。对于射线r和小面t，v~0~，v~1~和v~2~是t的三个顶点。表示r和t的每一条边的相对位置方向量O~i~可以通过公式(16)计算得到。

$$ 
O_i =\begin{vmatrix}
A_x^i & A_y^i\\
A_x^j & A_y^j
\end{vmatrix} \tag{16}
$$

$$A_x^i = v_{i,x} - r_x \tag{17}$$

$$A_y^i = v_{i,y} - r_y \tag{18}$$

其中，$0 \le i \le 2,\quad j = i \% 3 + 1$。
<font color=#FF00FF size=4 face="楷体"><b><bys>这里我感觉作者写错了，应该是j = (i + 1) % 3。</bys></b></font>

O~i~表示边$\vec{v_iv_j}$和射线r的相对位置。如果O~i~>0，则r位于边$\vec{v_iv_j}$的左侧。反之，如果O~i~<0，r位于边$\vec{v_iv_j}$的右侧。如果三条边的O~i~满足条件：$\bigcap O_i > 0$或$\bigcap O_i < 0$，那么射线必定穿过三角形小面t。位置关系有一些特殊情况，例如射线穿过小面的顶点。将在2.5节分析所有情况。
如果一个小面通过了射线的交点测试，则可以使用公式(19)计算得到射线的交点z坐标。射线方向的所有交点都按升序排列，形成有序数组。在网格生成的最后一步中，物质的属性需要映射到网格单元。射线中的网格单元通过交点划分为一些列。列数必须是偶数，可以表示为2n。在射线方向上，第i个单元可以使用公式(20)映射。

$$r_z = v_{0,z} + A_x^0\cdot \frac{n_x}{n_z} + A_y^0\cdot \frac{n_y}{n_z} \tag{{19}}$$

其中r~z~为交点的z坐标。
$$
cell_r^i = \begin{cases}1,\quad r_z^{2n-1} < i\cdot s_z \le r_z^(2n) \\
0,\quad else
\end{cases} \tag{20}
$$

其中，$cell_r^i$是r方向的属性标志。

##### *Degenerate Detection*(退化检测？？？)

如图6所示，在三维空间中，射线和三角形小面之间的关系可以分为7类：穿过面、错过、穿过顶点、穿过边、平行、共面非相交和共面相交。很明显，用上述方法可以判断是穿过面还是错过并计算出交点。然而，其他情况可能无法正确判断。在本节中，分析了所有可能性，以提高算法的稳定性。

<div align=center><img width="400" src="/applsci-10-00058-g006-550.jpg"></div> 
<div align=center><font color=#FF0000 size=4 face="楷体"><b>图6 三维空间中射线和三角形间的交点情况</b></font></div>

如上所述，获得了三个方向量O~0~、O~1~和O~2~。交叉点是射线穿过小面顶点的关系。同时，由于几何体是封闭的，这条射线一定也穿过其他小面的顶点。在这种情况下，一定有两个方向量等于0，另外一个方向量不为0。相交判断通过，但是同一交点可以通过不止一个小面计算得到。如2.4节所述，交点将沿r方向排序，同一点仅保留一次。穿过边是射线穿过小面的边的关系。根据相同的原则，有一个方向量必须为0，其他两个方向量必须同时为正或同时为负。两个相同的交点可以通过不同的小面计算得到，并且只保留一个。
当射线与小面平行时，三个方向量不能同时为正或为负。因此，这种关系被判断为错过，这符合事实。当射线与小面共面但不相交时，三个方向量一定都为0。这种关系被判断为错过，这也符合事实。对于最后一种，射线与小面共面并且穿过它。三个方向量一定全为0。在这种情况下，小面一定是几何体边界的一部分，其中小面不可能包含网格。因此，可以正确判定其为错过的事实。
一般情况下，射线投射算法需要增加对穿过顶点和穿过边情况的判断，以保证算法在所有情况下都是正确的。具体来说，如果计算得到的两个方向量都为0，那么该关系可被视为穿过顶点。类似的，如果一个方向量等于0，并且其他两个方向量具有相同的符号，则该关系可以被视为穿过边。在这两种额外的情况下，需要在下一步计算交点。
并行笛卡尔网格生成算法的总体流程图如图7所示。三个需要消耗大量时间的步骤为：射线生成、交点计算和属性映射计算。如图7绿色部分所示，通过上述小节描述的方法使用GPU并行实现。


<div align=center><img width="400" src="/applsci-10-00058-g007-550.jpg"></div> 
<div align=center><font color=#FF0000 size=4 face="楷体"><b>图7 基于GPU并行射线投射法的笛卡尔网格生成算法流程图</b></font></div>

#### *Results and Discussion*

##### *Result and Visualization of Cartesian Mesh Generation*


